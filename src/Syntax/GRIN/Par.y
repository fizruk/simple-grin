-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Syntax.GRIN.Par
  ( happyError
  , myLexer
  , pProgram
  , pBinding
  , pListBinding
  , pListVar
  , pExp
  , pCaseExp
  , pListCaseExp
  , pExp1
  , pSimpleVal
  , pListSimpleVal
  , pVal
  , pLPat
  , pCPat
  , pLiteral
  ) where

import Prelude

import qualified Syntax.GRIN.Abs
import Syntax.GRIN.Lex

}

%name pProgram Program
%name pBinding Binding
%name pListBinding ListBinding
%name pListVar ListVar
%name pExp Exp
%name pCaseExp CaseExp
%name pListCaseExp ListCaseExp
%name pExp1 Exp1
%name pSimpleVal SimpleVal
%name pListSimpleVal ListSimpleVal
%name pVal Val
%name pLPat LPat
%name pCPat CPat
%name pLiteral Literal
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '$' { PT _ (TS _ 1) }
  '(' { PT _ (TS _ 2) }
  '()' { PT _ (TS _ 3) }
  ')' { PT _ (TS _ 4) }
  ';' { PT _ (TS _ 5) }
  '=' { PT _ (TS _ 6) }
  'False' { PT _ (TS _ 7) }
  'True' { PT _ (TS _ 8) }
  'case' { PT _ (TS _ 9) }
  'fetch' { PT _ (TS _ 10) }
  'of' { PT _ (TS _ 11) }
  'store' { PT _ (TS _ 12) }
  'unit' { PT _ (TS _ 13) }
  'update' { PT _ (TS _ 14) }
  '{' { PT _ (TS _ 15) }
  '}' { PT _ (TS _ 16) }
  'λ' { PT _ (TS _ 17) }
  '→' { PT _ (TS _ 18) }
  L_integ  { PT _ (TI $$) }
  L_Tag { PT _ (T_Tag $$) }
  L_Var { PT _ (T_Var $$) }

%%

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

Tag :: { Syntax.GRIN.Abs.Tag }
Tag  : L_Tag { Syntax.GRIN.Abs.Tag $1 }

Var :: { Syntax.GRIN.Abs.Var }
Var  : L_Var { Syntax.GRIN.Abs.Var $1 }

Program :: { Syntax.GRIN.Abs.Program }
Program : ListBinding { Syntax.GRIN.Abs.Program $1 }

Binding :: { Syntax.GRIN.Abs.Binding }
Binding : Var ListVar '=' '{' Exp '}' { Syntax.GRIN.Abs.Binding $1 $2 $5 }

ListBinding :: { [Syntax.GRIN.Abs.Binding] }
ListBinding : {- empty -} { [] }
            | Binding { (:[]) $1 }
            | Binding ';' ListBinding { (:) $1 $3 }

ListVar :: { [Syntax.GRIN.Abs.Var] }
ListVar : {- empty -} { [] } | Var ListVar { (:) $1 $2 }

Exp :: { Syntax.GRIN.Abs.Exp }
Exp : Exp1 '$' 'λ' LPat '→' ';' Exp { Syntax.GRIN.Abs.Sequencing $1 $4 $7 }
    | 'case' Val 'of' '{' ListCaseExp '}' { Syntax.GRIN.Abs.Case $2 $5 }
    | Exp1 { $1 }

CaseExp :: { Syntax.GRIN.Abs.CaseExp }
CaseExp : CPat '→' '{' Exp '}' { Syntax.GRIN.Abs.CaseExp $1 $4 }

ListCaseExp :: { [Syntax.GRIN.Abs.CaseExp] }
ListCaseExp : {- empty -} { [] }
            | CaseExp { (:[]) $1 }
            | CaseExp ';' ListCaseExp { (:) $1 $3 }

Exp1 :: { Syntax.GRIN.Abs.Exp }
Exp1 : Var ListSimpleVal { Syntax.GRIN.Abs.App $1 $2 }
     | 'unit' Val { Syntax.GRIN.Abs.Unit $2 }
     | 'store' Val { Syntax.GRIN.Abs.Store $2 }
     | 'fetch' Var { Syntax.GRIN.Abs.Fetch $2 }
     | 'update' Var Val { Syntax.GRIN.Abs.Update $2 $3 }
     | '(' Exp ')' { $2 }

SimpleVal :: { Syntax.GRIN.Abs.SimpleVal }
SimpleVal : Literal { Syntax.GRIN.Abs.SimpleLiteral $1 }
          | Var { Syntax.GRIN.Abs.SimpleVar $1 }

ListSimpleVal :: { [Syntax.GRIN.Abs.SimpleVal] }
ListSimpleVal : {- empty -} { [] }
              | SimpleVal ListSimpleVal { (:) $1 $2 }

Val :: { Syntax.GRIN.Abs.Val }
Val : '(' Tag ListSimpleVal ')' { Syntax.GRIN.Abs.ConstantTag $2 $3 }
    | '(' Var ListSimpleVal ')' { Syntax.GRIN.Abs.VariableTag $2 $3 }
    | Tag { Syntax.GRIN.Abs.SingleTag $1 }
    | '()' { Syntax.GRIN.Abs.Empty }
    | SimpleVal { Syntax.GRIN.Abs.SimpleVal $1 }

LPat :: { Syntax.GRIN.Abs.LPat }
LPat : Val { Syntax.GRIN.Abs.LPat $1 }

CPat :: { Syntax.GRIN.Abs.CPat }
CPat : '(' Tag ListVar ')' { Syntax.GRIN.Abs.ConstNodePattern $2 $3 }
     | Tag { Syntax.GRIN.Abs.ConstTagPattern $1 }
     | Literal { Syntax.GRIN.Abs.ConstLiteral $1 }

Literal :: { Syntax.GRIN.Abs.Literal }
Literal : Integer { Syntax.GRIN.Abs.LitInteger $1 }
        | 'False' { Syntax.GRIN.Abs.LitBoolFalse }
        | 'True' { Syntax.GRIN.Abs.LitBoolTrue }
{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

