-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Syntax.Fun.Par
  ( happyError
  , myLexer
  , pListVar
  , pProgram
  , pBinding
  , pListBinding
  , pExp
  , pExp1
  , pExp2
  , pListExp2
  , pCaseExp
  , pListCaseExp
  , pAtom
  , pListAtom
  , pLiteral
  , pPat
  ) where

import Prelude

import qualified Syntax.Fun.Abs
import Syntax.Fun.Lex

}

%name pListVar ListVar
%name pProgram Program
%name pBinding Binding
%name pListBinding ListBinding
%name pExp Exp
%name pExp1 Exp1
%name pExp2 Exp2
%name pListExp2 ListExp2
%name pCaseExp CaseExp
%name pListCaseExp ListCaseExp
%name pAtom Atom
%name pListAtom ListAtom
%name pLiteral Literal
%name pPat Pat
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  '->' { PT _ (TS _ 3) }
  ';' { PT _ (TS _ 4) }
  '=' { PT _ (TS _ 5) }
  'case' { PT _ (TS _ 6) }
  'in' { PT _ (TS _ 7) }
  'let' { PT _ (TS _ 8) }
  'letS' { PT _ (TS _ 9) }
  'of' { PT _ (TS _ 10) }
  '{' { PT _ (TS _ 11) }
  '}' { PT _ (TS _ 12) }
  L_integ  { PT _ (TI $$) }
  L_Con { PT _ (T_Con $$) }
  L_Var { PT _ (T_Var $$) }

%%

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

Con :: { Syntax.Fun.Abs.Con }
Con  : L_Con { Syntax.Fun.Abs.Con $1 }

Var :: { Syntax.Fun.Abs.Var }
Var  : L_Var { Syntax.Fun.Abs.Var $1 }

ListVar :: { [Syntax.Fun.Abs.Var] }
ListVar : {- empty -} { [] } | Var ListVar { (:) $1 $2 }

Program :: { Syntax.Fun.Abs.Program }
Program : ListBinding { Syntax.Fun.Abs.Program $1 }

Binding :: { Syntax.Fun.Abs.Binding }
Binding : Var ListVar '=' Exp { Syntax.Fun.Abs.Binding $1 $2 $4 }

ListBinding :: { [Syntax.Fun.Abs.Binding] }
ListBinding : {- empty -} { [] }
            | Binding { (:[]) $1 }
            | Binding ';' ListBinding { (:) $1 $3 }

Exp :: { Syntax.Fun.Abs.Exp }
Exp : 'case' Exp1 'of' '{' ListCaseExp '}' { Syntax.Fun.Abs.Case $2 $5 }
    | 'let' Var '=' Exp1 'in' Exp { Syntax.Fun.Abs.Let $2 $4 $6 }
    | 'letS' Var '=' Exp1 'in' Exp { Syntax.Fun.Abs.LetS $2 $4 $6 }
    | Exp1 { $1 }

Exp1 :: { Syntax.Fun.Abs.Exp }
Exp1 : Con ListExp2 { Syntax.Fun.Abs.Constructor $1 $2 }
     | Exp2 Exp2 ListExp2 { Syntax.Fun.Abs.App $1 $2 $3 }
     | Exp2 { $1 }

Exp2 :: { Syntax.Fun.Abs.Exp }
Exp2 : Atom { Syntax.Fun.Abs.Atom $1 } | '(' Exp ')' { $2 }

ListExp2 :: { [Syntax.Fun.Abs.Exp] }
ListExp2 : {- empty -} { [] } | Exp2 ListExp2 { (:) $1 $2 }

CaseExp :: { Syntax.Fun.Abs.CaseExp }
CaseExp : Pat '->' Exp { Syntax.Fun.Abs.CaseExp $1 $3 }

ListCaseExp :: { [Syntax.Fun.Abs.CaseExp] }
ListCaseExp : {- empty -} { [] }
            | CaseExp { (:[]) $1 }
            | CaseExp ';' ListCaseExp { (:) $1 $3 }

Atom :: { Syntax.Fun.Abs.Atom }
Atom : Var { Syntax.Fun.Abs.AtomVar $1 }
     | Literal { Syntax.Fun.Abs.AtomLiteral $1 }

ListAtom :: { [Syntax.Fun.Abs.Atom] }
ListAtom : {- empty -} { [] } | Atom ListAtom { (:) $1 $2 }

Literal :: { Syntax.Fun.Abs.Literal }
Literal : Integer { Syntax.Fun.Abs.LitInteger $1 }

Pat :: { Syntax.Fun.Abs.Pat }
Pat : Con ListVar { Syntax.Fun.Abs.ConPat $1 $2 }
    | Literal { Syntax.Fun.Abs.LitPat $1 }
{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

